üéØ 1. Mi az a szoftvertechnol√≥gia?
Professzion√°lis szoftverfejleszt√©s m√≥dszertana.

C√©lja: funkcionalit√°s, min≈ës√©g, k√∂lts√©g √©s hat√°rid≈ë garant√°l√°sa.

A szoftver nemcsak k√≥d, hanem: programok, dokument√°ci√≥k, konfigur√°ci√≥k √©s adatok egy√ºttese.

‚úÖ 2. Min≈ës√©gi mutat√≥k (quality characteristics)
Karbantarthat√≥s√°g (maintainability) ‚Äì k√∂nnyen m√≥dos√≠that√≥, b≈ëv√≠thet≈ë

Megb√≠zhat√≥s√°g, biztons√°g (dependability, security) ‚Äì hib√°k, t√°mad√°sok elleni v√©delem

Hat√©konys√°g (efficiency) ‚Äì er≈ëforr√°s-haszn√°lat, v√°laszid≈ë

Haszn√°lhat√≥s√°g (usability) ‚Äì egyszer≈±s√©g, tanulhat√≥s√°g

üë∑ 3. Szoftvertechnol√≥giai projekt szerepei
Projektmenedzser ‚Äì vezet√©s, er≈ëforr√°s, min≈ës√©g, dokument√°ci√≥

Term√©kgazda ‚Äì √ºzleti √©rt√©kek, priorit√°s

Programgazda ‚Äì √ºtemez√©s, nyomon k√∂vet√©s

Tervez≈ë ‚Äì technikai architekt√∫ra

Fejleszt≈ë

Tesztel≈ë / QA ‚Äì tesztel√©s, ellen≈ërz√©s

üîÅ 4. Szoftver √©letciklus ‚Äì f≈ë f√°zisai
Specifik√°ci√≥ ‚Äì mit kell csin√°lni

Tervez√©s √©s implement√°ci√≥ ‚Äì hogyan m≈±k√∂dj√∂n

Verifik√°ci√≥ √©s valid√°ci√≥ ‚Äì tesztel√©s, megfelel√©s

Evol√∫ci√≥ ‚Äì hibajav√≠t√°s, b≈ëv√≠t√©s

üìÑ 5. Specifik√°ci√≥ r√©szl√©p√©sei
Megval√≥s√≠that√≥s√°g elemz√©se

K√∂vetelm√©nyek felt√°r√°sa √©s dokument√°l√°sa

K√∂vetelm√©ny specifik√°ci√≥

K√∂vetelm√©ny valid√°ci√≥ ‚Üí eredm√©ny: SRS (Software Requirements Specification)

üß† 6. Tervez√©s & implement√°ci√≥
Szoftver rendszerterv k√©sz√≠t√©se (statikus + dinamikus)

Haszn√°lhat√≥ protot√≠pus (horizont√°lis: UI, vertik√°lis: funkcionalit√°s)

Verzi√≥kezel√©s, IDE, tesztel√©s

üß≠ 7. Programoz√°si paradigm√°k
Procedur√°lis, objektumorient√°lt, funkcion√°lis, logikai, adatfolyam-alap√∫

Meghat√°rozz√°k a k√≥d st√≠lus√°t, nyelvv√°laszt√°st, absztrakci√≥kat

‚úîÔ∏è 8. Valid√°ci√≥ & evol√∫ci√≥
Valid√°ci√≥: megfelel a k√∂vetelm√©nyeknek?

Evol√∫ci√≥: √∫j ig√©nyekhez illeszt√©s (√©lettartam 80%-a!)

üì¶ 9. Dokument√°ci√≥ t√≠pusai
Felhaszn√°l√≥i: √ºzembe helyez√©s, funkci√≥k

Fejleszt≈ëi: technikai r√©szletek, implement√°ci√≥

‚è± 10. √útemterv & m√©rf√∂ldk√∂vek
Hierarchikus feladatszerkezet

F√ºgg≈ës√©gek, felel≈ës√∂k, hat√°rid≈ëk

M√©rf√∂ldk≈ë = ellen≈ërizhet≈ë c√©l, st√°tusz pont

üí° 11. UML 5 n√©zete
Haszn√°lati n√©zet ‚Äì user funkci√≥k (use case)

Szerkezeti ‚Äì oszt√°lyok, komponensek

Dinamikus ‚Äì viselked√©s, √°llapot, szekvencia

Implement√°ci√≥s ‚Äì k√≥d, komponensek

K√∂rnyezeti ‚Äì hardver, szoftver kapcsolatok

üõ†Ô∏è 12. Hasznos eszk√∂z√∂k
Project tracking

CASE tool

IDE

Version Control (Git)

CI/CD tools

üîÅ 13. Fejleszt√©si modellek
üîπ V√≠zes√©s (Waterfall)
Line√°ris, el≈ëre defini√°lt

‚úÖ Struktur√°lt

‚ùå Nem kezeli v√°ltoz√°sokat

üîπ Spir√°lis (Spiral)
Protot√≠pus + kock√°zatvez√©relt

‚úÖ J√≥ kock√°zatkezel√©s

‚ùå K√∂lts√©ges

üîπ Inkrement√°lis
Funkci√≥k l√©p√©sr≈ël l√©p√©sre

‚úÖ Gyors feedback

‚ùå √Åtl√°that√≥s√°g gyenge

‚ö° 14. Agilis fejleszt√©s
Inkrement√°lis, gyors kiad√°s (continuous delivery)

√ârt√©kek (Agilis Ki√°ltv√°ny szerint):

Egy√©nek > folyamatok

M≈±k√∂d≈ë k√≥d > dokument√°ci√≥

√úgyf√©l egy√ºttm≈±k√∂d√©s > szerz≈ëd√©s

Reag√°l√°s > terv k√∂vet√©se

üåÄ 15. Scrum m√≥dszer
Sprint (2‚Äì4 h√©t) + tervez√©s + review + retrospective

Nincs projektmenedzser ‚Üí van Scrum Master

Product backlog + sprint planning + daily stand-up

üìö 16. Modellek csoportos√≠t√°sa
T√≠pus C√©l
Terv-vez√©relt Min≈ës√©g, stabilit√°s
Agilis Rugalmass√°g, egyszer≈±s√©g
Form√°lis Bizony√≠that√≥ helyess√©g

<!-- 2 -->

üéØ 1. Mi az a specifik√°ci√≥ √©s mi√©rt fontos?
C√©lja: A szoftver c√©ljainak, funkci√≥inak, korl√°tainak √©s elv√°r√°sainak pontos meghat√°roz√°sa felhaszn√°l√≥i √©s fejleszt≈ëi oldalr√≥l is.

Eredm√©nye: A Software Requirements Specification (SRS) dokumentum.

üîÑ 2. A specifik√°ci√≥ l√©p√©sei:

1. Megval√≥s√≠that√≥s√°gi elemz√©s (Feasibility Study)
   Vizsg√°lja, hogy:

Lehets√©ges-e a megval√≥s√≠t√°s technikailag √©s gazdas√°gilag?

Milyen er≈ëforr√°sok sz√ºks√©gesek (hum√°n, szoftver, hardver)?

Milyen lesz az √ºzemeltet√©s, karbantart√°s k√∂lts√©ge?

Gyors √©s olcs√≥ elemz√©s ‚Üí ha egyedi projekt: aj√°nlatt√©tel k√∂veti.

2. K√∂vetelm√©nyfelt√°r√°s √©s -elemz√©s (Elicitation & Analysis)
   H√°rom l√©p√©s:

Kutat√°s: interj√∫k, megl√©v≈ë rendszerek vizsg√°lata.

Oszt√°lyoz√°s: csoportos√≠t√°s, alrendszerekhez rendel√©s.

Priorit√°s: fontoss√°g szerinti sorrend, feleslegesek kisz≈±r√©se.

Neh√©zs√©gek:

Vev≈ë bizonytalan / nem informatika szak√©rt≈ë

Elt√©r≈ë ig√©nyek, v√°ltoz√≥ k√∂rnyezet

3. K√∂vetelm√©nyek t√≠pusai:
   üìå Funkcion√°lis k√∂vetelm√©nyek:
   Mit csin√°l a rendszer: funkci√≥k, reakci√≥k, viselked√©s

üìå Nem funkcion√°lis k√∂vetelm√©nyek:
Hogyan viselkedjen a rendszer. Pl.:

Hat√©konys√°g (Efficiency) ‚Äì er≈ëforr√°s-haszn√°lat

Megb√≠zhat√≥s√°g (Dependability) ‚Äì hibakezel√©s, robusztuss√°g

Biztons√°g (Security) ‚Äì hozz√°f√©r√©sv√©delem

Hordozhat√≥s√°g (Portability) ‚Äì platformf√ºggetlens√©g

Haszn√°lhat√≥s√°g (Usability) ‚Äì k√∂nnyen kezelhet≈ë

üìå Menedzsel√©si k√∂vetelm√©nyek:
K√∂rnyezet (kell-e m√°s szoftver, milyen g√©pen fut)

Fejleszt√©si k√∂rnyezet, nyelvek, m√≥dszertan

M≈±k√∂d√©si param√©terek (id≈ë, gyakoris√°g)

üìå K√ºls≈ë k√∂vetelm√©nyek:
T√∂rv√©nyi, etikai, jogi megfelel√©s

üß© 3. P√©ld√°k ‚Äì esettanulm√°nyok
ü•™ Marika n√©ni k√°v√©z√≥ja
Funkci√≥k:

√âtel/ital hozz√°ad√°s

Rendel√©sek, t√∂rzsv√°s√°rl√≥i sz√°m

Statisztik√°k (nap/h√≥nap/t√∂rzsv√°s√°rl√≥)

Adatment√©s sz√∂veges f√°jlba

Nem-funkcion√°lis p√©lda:

Csak Windows 7+, nem garant√°lt adatbiztons√°g

Felhaszn√°l√≥bar√°t, de kev√©s adatot kezel

üÉè Memory j√°t√©k
Aktor: j√°t√©kos

Funkci√≥k:

K√°rtyacsomag √©s n√©v v√°laszt√°s, j√°t√©k ind√≠t√°s

K√©t k√°rtya felford√≠t√°sa (ha egyezik ‚Üí marad, ha nem ‚Üí vissza)

Diagramok: include, precedes rel√°ci√≥k

üè† Utaz√°si √ºgyn√∂ks√©g
Aktor: felhaszn√°l√≥, admin

Webes fel√ºlet: keres√©s, foglal√°s

Admin: √∫j apartman hozz√°ad√°s, k√©pek felt√∂lt√©se

Adatb√°zis m≈±veletek: √ºtk√∂z√©skezel√©s, t√°rol√°s, lek√©rdez√©s

üóÇ 4. Haszn√°lati esetek (Use Cases)
Aktor: aki haszn√°lja a rendszert (pl. B√ºf√©s, J√°t√©kos, Admin)

Funkci√≥: a rendszer szolg√°ltat√°sai

Kapcsolatok:

include: r√©sze egy m√°siknak (k√∂telez≈ë)

extend: opcion√°lis b≈ëv√≠t√©s

precedes: sorrend (el≈ëfelt√©tel)

invokes: k√∂vetkezm√©ny

‚úçÔ∏è 5. Felhaszn√°l√≥i t√∂rt√©netek (User Stories)
Form√°tum:

css
M√°sol√°s
Szerkeszt√©s
As a [user role], I want to [goal], so that [reason]
B≈ëv√≠t√©s Given‚ÄìWhen‚ÄìThen form√°ban:

Given ‚Äì adott k√∂rnyezet

When ‚Äì esem√©ny

Then ‚Äì elv√°rt v√°lasz

P√©lda:
As a B√ºf√©s, I want to add an item to the order.

Given the item menu is opened

When I enter a valid name and price

Then it gets added to the order

‚úÖ 6. K√∂vetelm√©ny valid√°ci√≥
C√©l: A specifik√°ci√≥ konzisztens, val√≥szer≈±, ellen≈ërizhet≈ë legyen

Eredm√©ny:

Protot√≠pus (gyors tesztel√©shez)

Tesztesetek (v√©gs≈ë valid√°ci√≥hoz)

üìÑ 7. K√∂vetelm√©ny-le√≠r√°s (SRS dokumentum fel√©p√≠t√©se)
El≈ësz√≥

Bevezet√©s

Fogalomt√°r

K√∂vetelm√©nyek ‚Äì felhaszn√°l√≥i

Rendszer architekt√∫ra

K√∂vetelm√©nyek ‚Äì fejleszt≈ëi r√©szletes le√≠r√°s

Rendszermodellek (pl. UI mockup, adatmodell)

Evol√∫ci√≥ (j√∂v≈ëbeli b≈ëv√≠t√©sek)

F√ºggel√©k

T√°rgymutat√≥

<!-- 3 -->

üéØ 1. Objektumorient√°lt tervez√©s alapjai
üîπ Objektumok, oszt√°lyok
Objektum = val√≥s√°g absztrakci√≥ja: adat + m≈±k√∂d√©s

Oszt√°ly = objektumok sablonja (azonos funkci√≥ + √°llapot)

Elemz√©s sor√°n:

Azonos√≠tjuk a funkci√≥kat ‚Üí ezekhez rendelj√ºk az adatokat ‚Üí ebb≈ël lesznek az oszt√°lyok

üß± 2. Tervez√©si f√°zisok
T√∂bbl√©pcs≈ës, iterat√≠v folyamat

Minden f√°zisban lehet:

√∫j oszt√°ly bevezet√©se

megl√©v≈ë pontos√≠t√°sa vagy feloszt√°sa / √∂sszevon√°sa

üß≠ 3. SOLID alapelvek
R√∂vid√≠t√©s Elv neve Jelent√©s
SRP Single Responsibility Egy oszt√°ly csak egy felel≈ëss√©ggel b√≠rjon
OCP Open/Closed Nyitott b≈ëv√≠t√©sre, z√°rt m√≥dos√≠t√°sra
LSP Liskov Substitution Alt√≠pus helyettes√≠thet≈ës√©g
ISP Interface Segregation Sok kicsi interf√©sz, ne egy nagy
DIP Dependency Inversion Az absztrakci√≥t√≥l f√ºggj√ºnk, ne a konkr√©tt√≥l

üß± 4. Szoftverarchitekt√∫ra
Els≈ëdleges d√∂nt√©sek √∂sszess√©ge, amelyek a rendszer szerkezet√©t, viselked√©s√©t, sk√°l√°zhat√≥s√°g√°t, stb. meghat√°rozz√°k

Architektur√°lis minta: eg√©sz rendszer strukt√∫r√°ja (pl. MVC)

Tervminta (design pattern): kisebb r√©szek kapcsolata (pl. Factory, Observer)

üß± 5. Architekt√∫rat√≠pusok
Monolitikus
Minden egy blokkban: adatkezel√©s + GUI + logika egy√ºtt

Modell / N√©zet (Model/View)
Modell: alkalmaz√°slogika (√°llapot + adatok)

N√©zet: GUI + esem√©nykezel√©s

Modell nem ismeri a n√©zetet, de a n√©zet figyelhet modellre (pl. observer)

üß™ 6. Esettanulm√°ny: Marika n√©ni k√°v√©z√≥ja
Objektumok:

Item (sz√ºl≈ëoszt√°ly) ‚Üí Hamburger, Ufo, Pancake, Tea, Coke, Orange

Order ‚Üí t√©telek list√°ja, d√°tum, k√°rtyasz√°m

Menu ‚Üí rendel√©sek list√°ja, men√º logika

Adatt√°rol√°s:

F√°jlform√°tum: .dat, CSV-szer≈± (pontosvessz≈ë + sort√∂r√©s)

<rendel√©s_id>;<d√°tum>;<k√°rtyasz√°m>;<t√©telek_sz√°ma>

üÉè 7. Esettanulm√°ny: Memory j√°t√©k
Modell oszt√°lyok:

GameManager, CardPack, Player

N√©zet oszt√°lyok:

MainWindow, GameWidget, ConfigurationDialog, ImageButton

Adatt√°rol√°s:

name.txt ‚Äì csomag neve

back.png ‚Äì h√°tlap

0.png, 1.png, ‚Ä¶ ‚Äì el≈ëlapok k√©pei

üè® 8. Esettanulm√°ny: Utaz√°si √ºgyn√∂ks√©g
Felhaszn√°l√≥i kliens:

Webes kliens (JRE + weblap)

Asztali alkalmaz√°s (JRE)

Szerver oldalon:

Webszolg√°ltat√°s (Spring) ‚Üí DB k√∂zvet√≠t√©s

Adatb√°zis s√©ma:

city, building, apartment, customer, stb.

üì¶ 9. UML diagramok
Diagram C√©l
Csomagdiagram (package) Logikai egys√©gek, csomagok kapcsolatai
Komponensdiagram Komponensek, interf√©szek, kapcsolat (pl. SQL, API)
Telep√≠t√©si diagram (deployment) Hardver/szoftver elemek elhelyez√©se, csom√≥pontok
Oszt√°lydiagram Statikus szerkezet
Szekvencia/√°llapot diagram Dinamikus m≈±k√∂d√©s (pl. esem√©nyek, √°llapotok)

üßæ 10. Rendszerterv (Software Design Description ‚Äì SDD)
Fel√©p√≠t√©se:
El≈ësz√≥

Bevezet√©s

Fogalomt√°r

Architekt√∫ra (UML + minta)

Adattervez√©s

Rendszerterv (oszt√°lyok, √°llapotok, interf√©szek)

Fel√ºlet

Implement√°ci√≥s aj√°nl√°sok

F√ºggel√©k

T√°rgymutat√≥

<!-- 4 -->

üìï ea04 ‚Äì Objektumorient√°lt tervez√©si szempontok √©s mint√°k

1. SOLID alapelvek
   SRP (Single Responsibility Principle): Egy oszt√°ly csak egyetlen felel≈ëss√©ggel b√≠rjon.
   P√©lda: k√∂nyvkeres√©st (locate) a k√∂nyvt√°ros haszn√°lja, ki√≠rat√°st (print) az olvas√≥. Ezek k√ºl√∂n oszt√°lyokban: BookLocator, BookPrinter.

OCP (Open/Closed Principle): A k√≥d legyen nyitott b≈ëv√≠t√©sre, de z√°rt m√≥dos√≠t√°sra.
P√©lda: minden Shape (pl. Circle, Rectangle) maga sz√°molja ki a getArea(), √≠gy nem kell √∫j if-et √≠rni √∫j alakzat eset√©n.

LSP (Liskov Substitution Principle): Egy oszt√°ly alt√≠pusa helyettes√≠thet≈ë az eredetivel an√©lk√ºl, hogy hib√°s m≈±k√∂d√©st okozna.
P√©lda: Square nem felel meg a Rectangle √∂r√∂kl√©snek, mert setHeight() ‚Üí setWidth().

ISP (Interface Segregation Principle): Egy oszt√°ly csak azokat a m≈±veleteket l√°ssa, amiket haszn√°l.
P√©lda: EmailClient csak az Emailable-t haszn√°lja, PhoneClient csak a Callable-t.

DIP (Dependency Inversion Principle): A fels≈ëbb oszt√°lyok absztrakt interf√©szekre √©p√ºljenek, ne konkr√©t implement√°ci√≥kra.
P√©lda: Client a Calculator interf√©szt kapja konstruktorban, nem p√©ld√°nyos√≠t LogCalculator-t.

2. F√ºgg≈ës√©g befecskendez√©s (Dependency Injection)
   A kliens nem p√©ld√°nyos√≠tja a szolg√°ltat√°st, hanem k√ºls≈ë komponens adja √°t neki.

Lehets√©ges form√°k: konstruktor, met√≥dus, vagy interf√©sz alap√∫ injekt√°l√°s.

P√©lda: Injector adja a Client-nek a Calculator-t.

3. Tervez√©si mint√°k
   Factory ‚Äì p√©ld√°nyos√≠t√°si logika elrejt√©se

Factory Method ‚Äì lesz√°rmazott hat√°rozza meg, mit gy√°rt

Abstract Factory ‚Äì kapcsol√≥d√≥ objektumok gy√°rt√°sa egy helyen

Command ‚Äì egy tev√©kenys√©g (pl. Execute) objektumm√° alak√≠t√°sa, amit az Invoker h√≠v

4. Architekt√∫r√°k
   Monolitikus ‚Äì minden egy f√°jlban; rosszul sk√°l√°zhat√≥

Model‚ÄìView ‚Äì modell a logika √©s adat, n√©zet az UI; nem el√©g elk√ºl√∂n√≠tett

3-Tier ‚Äì

N√©zet (View)

√úzleti logika (Logic)

Perzisztencia (Data)

MVC ‚Äì

Model: logika √©s √°llapot

View: fel√ºlet, deklarat√≠v

Controller: feldolgozza az esem√©nyeket
Webes rendszerekben k√ºl√∂n√∂sen elterjedt.

5. Adatk√∂t√©s √©s √°llapotok
   H√°rom f≈ë adat√°llapot:

Display state ‚Äì felhaszn√°l√≥ √°ltal l√°tott

Session state ‚Äì programban t√°rolt

Record state ‚Äì adatb√°zisban mentett

Adatk√∂t√©s (Data Binding):

Automatiz√°lt szinkroniz√°l√°s Binding objektummal

GetState(), SetState(), Convert()

N√©zet ismerheti a bindinget, modell nem

Figyel≈ë minta seg√≠t a szinkronban

6. Figyel≈ë minta (Observer)
   Subject: √©rtes√≠t minden figyel≈ët (Notify)

Observer: reag√°l a v√°ltoz√°sra (Update)

Modell nem ismeri a vez√©rl≈ët vagy n√©zetet ‚Äì csak esem√©nyt k√ºld

<!-- 5
 -->

üìò ea05 ‚Äì Projektmenedzsment eszk√∂z√∂k √©s verzi√≥kezel√©s

1. Fejleszt√©st t√°mogat√≥ eszk√∂z√∂k
   Projekt tracking system ‚Äì dokument√°l√°s, feladatk√∂vet√©s

CASE tool ‚Äì fejleszt√©si folyamat, felel≈ëss√©gek nyomon k√∂vet√©se

IDE ‚Äì integr√°lt fejleszt√©si k√∂rnyezet

Revision Control System (VCS) ‚Äì k√≥dv√°ltoz√°sok k√∂vet√©se

CI rendszer ‚Äì hib√°k automatikus √©szlel√©se fejleszt√©s sor√°n

2. Projektmenedzsment eszk√∂z funkci√≥i
   √útemterv, kock√°zatkezel√©s

Dokument√°ci√≥ l√©trehoz√°sa √©s friss√≠t√©se

Feladatkezel√©s (ticket/issue ‚Äì bug, feature, task, documentation)

Kommentel√©s, hat√°rid≈ëk, felel≈ës√∂k hozz√°rendel√©se

Verzi√≥kezel√©s √©s code review

3. N√©pszer≈± eszk√∂z√∂k
   Trac ‚Äì Python, MySQL/PostgreSQL/SQLite

Redmine ‚Äì Ruby on Rails

Azure DevOps ‚Äì Microsoft (TFVC, Git)

YouTrack ‚Äì JetBrains, Java + NoSQL (Xodus)

GitHub, GitLab, Bitbucket ‚Äì cloud-alap√∫ hosting

4. GitLab
   Webes fel√ºlet, projektmenedzsment + CI/CD integr√°ci√≥

K√©t v√°ltozat:

Community Edition ‚Äì self-hosted, ny√≠lt forr√°sk√≥d

Enterprise Edition ‚Äì v√°llalati funkci√≥k

ELTE GitLab: https://szofttech.inf.elte.hu/

feladatk√∂vet√©s, wiki, forr√°sk√≥dkezel√©s, automatikus tesztel√©s

5. Verzi√≥k√∂vet√©s c√©lja
   T√∂bbfejleszt≈ës munka szinkroniz√°l√°sa

√Ållapotment√©s (commit), visszavon√°s, vissza√°ll√≠t√°s

√Ågkezel√©s: branch, merge, tag

F√°jl- √©s sor-szint≈± v√°ltoz√°sk√∂vet√©s

Konfliktuskezel√©s + diff

6. Verzi√≥kezel≈ë gener√°ci√≥k
1. gener√°ci√≥ ‚Äì Lok√°lis (SCCS, RCS), f√°jlonk√©nti, z√°r alap√∫

1. gener√°ci√≥ ‚Äì K√∂zponti (CVS, SVN), kliens-szerver modell

1. gener√°ci√≥ ‚Äì Elosztott (Git, Mercurial), minden kliensn√©l teljes repo

1. Git parancs alapok
   git init, clone, add, commit, push, pull

git branch, checkout, merge

.gitignore f√°jl a kiz√°r√°sokhoz

Konfliktus: <<<<<<<, =======, >>>>>>>

8. Nagy f√°jlok kezel√©se
   Ne verzi√≥kezelj: build f√°jlok, bin√°risok, IDE be√°ll√≠t√°sok

.gitignore ‚Äì mint√°k GitHub-r√≥l: github/gitignore

Git LFS ‚Äì Nagy f√°jlokat k√ºls≈ë t√°ron t√°rol (linkelve)

9. Branch modellek
   GitFlow: master, develop, feature, release, hotfix

GitHub Flow: master + feature, gyors release

GitLab Flow: master, staging, production k√ºl√∂nv√°lasztva

10. T√°mogatott eszk√∂z√∂k
    GUI-k: TortoiseGit, SourceTree, GitKraken, SmartGit

IDE-k: IntelliJ IDEA (VCS men√º), NetBeans (Team men√º)

<!-- 6-->

üìó ea06 ‚Äì Build Systems (Ant, Maven, Gradle)

1. Why build systems?
   Manual compiling (e.g. javac, jar) is error-prone, slow, and hard to scale.

Build systems solve:

Compilation automation

Dependency management

Packaging (JAR, WAR, etc.)

Testing and reporting

Deployment automation

2. Ant (Imperative, XML-based)
   File: build.xml

Key concepts:

<project>: defines name, default target, basedir

<target>: defines a build step (e.g. compile, jar, clean, run)

<property>: key-value pairs, reusable via ${key}

Typical tasks:

prepare: create folders (e.g. mkdir dir="classes")

compile: compile Java with <javac>

jar: package classes into .jar with manifest

clean: delete output files/folders

test: run JUnit tests with <junit> and <batchtest>

run: launch JAR or class with <java>

Used in NetBeans (default) ‚Äì auto-generates build-impl.xml for hooks

3. Maven (Declarative, XML-based)
   File: pom.xml

Core concept: POM = Project Object Model

groupId, artifactId, version (GAV)

Build config, test config, dependencies

Lifecycle phases:

validate, compile, test, package, verify, install, deploy

mvn install: compiles, tests, packages, installs locally

mvn clean install: deletes old builds then runs full build

Dependencies:

Declared in <dependencies> block

Resolved from Maven Central ‚Üí stored in local repo (~/.m2/repository)

Scoped: compile, test, runtime, etc.

Plugins:

Extend functionality, e.g. maven-javadoc-plugin, surefire for test reports

Supports modular projects:

Parent POM + <modules>

4. Gradle (Script-based, Groovy/Kotlin DSL)
   File: build.gradle (or build.gradle.kts)

Features:

Combines Ant‚Äôs flexibility + Maven‚Äôs conventions

Faster builds (incremental)

Uses tasks (task name { doLast { ... } })

dependsOn defines task order

Plugins:

java ‚Äì build, test, jar, clean

application ‚Äì for executables (mainClass = ...)

Dependency config:

groovy
M√°sol√°s
Szerkeszt√©s
repositories { mavenCentral() }
dependencies {
implementation "..."
testImplementation "junit:junit:4.13.2"
}
Gradle Wrapper (gradlew) ensures version consistency across machines

Supported in IntelliJ IDEA, NetBeans

5. Summary of Tools
   Tool Language Style File Key Feature
   Ant Java Imperative build.xml Fine-grained task control
   Maven Java Declarative pom.xml Convention over config
   Gradle Any DSL-based build.gradle Fast, flexible, modern
